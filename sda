





//// TBT : 

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    int lbit;
    int rbit;
    struct Node* left;
    struct Node* right;
};

struct Node* createTBT(struct Node* head, int key) {
    struct Node* temp;
    struct Node* p;

    temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = key;
    temp->lbit = temp->rbit = 0;

    if (head->lbit == 0) {
        head->left = temp;
        temp->left = temp->right = head;
        head->lbit = 1;
        return head;
    }
    p = head->left;

    while (1) {
        if (key < p->data && p->lbit == 1) {
            p = p->left;
        } else if (key > p->data && p->rbit == 1) {
            p = p->right;
        } else {
            break;
        }
    }

    if (key < p->data) {
        temp->right = p;
        temp->left = p->left;
        p->lbit = 1;
        p->left = temp;
    } else {
        temp->right = p->right;
        temp->left = p;
        p->rbit = 1;
        p->right = temp;
    }

    return head;
}

void preOrder(struct Node* head) {
    struct Node* p;
    p = head->left;
    while (p != head) {
        printf("%d ", p->data);
        if (p->lbit == 1) {
            p = p->left;
        } else {
            while (p->rbit == 0 && p->right != head) {
                p = p->right;
            }
            p = p->right;
        }
    }
}


void inorderTBT(struct Node* head){
  
  struct Node* p = head->left;
  
  while(p->lbit != 0){
    p = p->left;
  }
  while(p != head){
    printf("%d ",p->data);
    
    if(p->rbit == 1){
      p = p->right;
      while(p->lbit != 0 ){
        p = p->left;
      }
    }else if(p->rbit == 0){
      p = p->right;
    }
  }
}


int main() {
    struct Node* head;
    head = (struct Node*)malloc(sizeof(struct Node));
    head->lbit = 0;
    head->rbit = 1;
    head->left = head->right = head;

    head = createTBT(head, 10);
    head = createTBT(head, 17);
    head = createTBT(head, 2);
    head = createTBT(head, 34);
    head = createTBT(head, 4);
    head = createTBT(head, 5);

    printf("Preorder: ");
    preOrder(head);
    
    printf("Inorder: ");
    inorderTBT(head);

    return 0;
}





//// AVL tree


#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    int height;
    struct Node* left;
    struct Node* right;
};

int MaxFun(int a, int b) {
    return (a > b) ? a : b;
}

int height(struct Node* root) {
    return (root == NULL) ? 0 : root->height;
}

int getbalance(struct Node* root) {
    return (root == NULL) ? 0 : height(root->left) - height(root->right);
}

struct Node* rightrotate(struct Node* y) {
    struct Node* x = y->left;
    struct Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = MaxFun(height(y->left), height(y->right)) + 1;
    x->height = MaxFun(height(x->left), height(x->right)) + 1;

    return x;
}

struct Node* leftrotate(struct Node* y) {
    struct Node* x = y->right;
    struct Node* T2 = x->left;

    x->left = y;
    y->right = T2;

    y->height = MaxFun(height(y->left), height(y->right)) + 1;
    x->height = MaxFun(height(x->left), height(x->right)) + 1;

    return x;
}

struct Node* insert(struct Node* root, int key) {
    if (root == NULL) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = key;
        node->height = 1;
        node->left = node->right = NULL;
        return node;
    }

    if (key < root->data) {
        root->left = insert(root->left, key);
    } else if (key > root->data) {
        root->right = insert(root->right, key);
    } else {
        return root;
    }

    root->height = 1 + MaxFun(height(root->left), height(root->right));
    int balance = getbalance(root);

    if (balance > 1 && key < root->left->data) {
        return rightrotate(root);
    }
    if (balance < -1 && key > root->right->data) {
        return leftrotate(root);
    }
    if (balance > 1 && key > root->left->data) {
        root->left = leftrotate(root->left);
        return rightrotate(root);
    }
    if (balance < -1 && key < root->right->data) {
        root->right = rightrotate(root->right);
        return leftrotate(root);
    }

    return root;
}

void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

int main() {
    int n;
    struct Node* root = NULL;

  
    scanf("%d", &n);

    
    for (int i = 0; i < n; i++) {
        int key;
        scanf("%d", &key);
        root = insert(root, key);
    }

    printf("Inorder traversal: ");
    inorder(root);
    printf("\n");

    return 0;
}




// hashing without replcaemnet 

// #include<stdio.h>
// #include<stdlib.h>

// #define size 10

// void insert(int data[],int chain[],int flag[],int x){

//     int start;
//     int i=0;
//     int j;
//     start = x % size;
    
//     while(flag[start] && i<size){
//         if(data[start]% size == x % size){
//             break;
//         }
//         i++;
//         start = (start + 1) % size;
//     }

//     if(i == size){
//         printf("hash table full\n");
//         return;
//     }

//     while(chain[start] != -1){
//         start = chain[start];
//     }
//      j = start;
//      while(flag[j] && i < size){
//         j = (j+1)%size;
//         i+=1;
//      }

//     if(i == size){
//         printf("hash table full\n");
//         return;
//     }

//     data[j]=x;
//     flag[j]=1;
//     if(j != start){
//         chain[start] = j;
//     }


// }





// void display(int data[],int chain[],int flag[]){
//     printf("Index\tData\tChain\tFlag\n");
//     for (int i = 0; i < size; i++)
//     {
//         if (flag[i])
//         {
//             printf("%d\t%d\t%d\t%d\n", i, data[i], chain[i], flag[i]);
//         }
//         else
//         {
//             printf("%d\t-\t-\t%d\n", i, flag[i]);
//         }
//     }
// }


// int main(){
//     int data[size];
//     int chain[size];
//     int flag[size];
//     int n,x;

//     for(int i=0;i<size;i++){
//         data[i] = -1;
//         chain[i] = -1;
//         flag[i] = 0;
//     }
//         printf("enter number of keys :");
//         scanf("%d",&n);

//         for(int i=0;i<n;i++){
//             printf("enter key :");
//             scanf("%d",&x);
//             insert(data,chain,flag,x);
//         }
     
//      printf("hashtable:\n");
//      display(data,chain,flag);
// }


//with replacement

#include <stdio.h>

void insert(int n, int key, int hashTable[][3])
{
    int i = 0, hash;
    hash = key % n;
    if (hashTable[hash][2] == 0)
    {
        hashTable[hash][0] = key;
        hashTable[hash][2] = 1;
    }
    else
    {
        if (hashTable[hash][0] % n != key % n)
        {
            int j = hash;
            int index = -1, data = hashTable[hash][0], chain = hashTable[hash][1];
            for (int k = 0; k < n; k++)
            {
                if (hashTable[k][1] == j)
                {
                    index = k;
                    break;
                }
            }
            hashTable[hash][0] = key;
            hashTable[hash][1] = -1;

            int newHash = (data) % n;
            while (hashTable[newHash][2] && i < n)
            {
                i++;
                newHash = (newHash + 1) % n;
            }
            if (i == n)
            {
                printf("Hash table is full\n");
                return;
            }
            hashTable[newHash][0] = data;
            hashTable[newHash][2] = 1;
            hashTable[newHash][1] = chain;
            if (index != -1)
                hashTable[index][1] = newHash;
        }
        else
        {
            int k = 0, j, index;
            index = key % n;
            while (hashTable[index][2] && k < n)
            {
                if (hashTable[index][0] % n == key % n)
                {
                    break;
                }
                k++;
                index = (index + 1) % n;
            }

            if (k == n)
            {
                printf("Hash table is full\n");
                return;
            }

            while (hashTable[index][1] != -1)
            {
                index = hashTable[index][1];
            }
            j = index;
            while (hashTable[j][2] && j < n)
            {
                j = (j + 1) % n;
                k++;
            }

            if (k == n)
            {
                printf("Hash table is full\n");
                return;
            }

            hashTable[j][0] = key;
            hashTable[j][2] = 1;

            if (j != index)
            {
                hashTable[index][1] = j;
            }
        }
    }
}

void display(int n, int hashTable[][3])
{
    printf("\nHash table : \n\n");

    printf("\nIndex\tKey\tChain\n");
    for (int i = 0; i < n; i++)
    {
        if (hashTable[i][2])
        {
            printf("%d|\t%d\t%d\n", i, hashTable[i][0], hashTable[i][1]);
        }
        else
        {
            printf("%d|\t-\t%d\n", i, hashTable[i][1]);
        }
    }
}

int main()
{
    int n, nk;
    printf("Enter size of hash table : ");
    scanf("%d", &n);
    printf("Enter number of keys you want to enter : ");
    scanf("%d", &nk);
    int hashTable[n][3];

    for (int i = 0; i < n; i++)
    {
        hashTable[i][1] = -1;
        hashTable[i][2] = 0;
    }

    for (int i = 0; i < nk; i++)
    {
        int a;
        printf("Enter key : ");
        scanf("%d", &a);
        insert(n, a, hashTable);
    }
    printf("\n");
    display(n, hashTable);
    return 0;
}









//// tree everything  not delete



#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct stack {
    struct Node* T;
    struct stack* next;
};

void push(struct stack** top, struct Node* temp) {
    struct stack *s = (struct stack*)malloc(sizeof(struct stack));
    s->next = (*top);
    s->T = temp;
    (*top) = s;
}

struct Node* pop(struct stack** top) {
    struct stack* temp;
    struct Node* N;
    temp = (*top);
    (*top) = (*top)->next;
    N = temp->T;
    free(temp);
    return N;
}

struct Node** createqueue(int* front, int* rear) {
    struct Node** queue = (struct Node**)malloc(50 * sizeof(struct Node*));
    *front = *rear = 0;
    return queue;
}

void enqueue(struct Node **queue, int *rear, struct Node *data) {
    queue[*rear] = data;
    (*rear)++;
}

struct Node *dequeue(struct Node **queue, int *front) {
    (*front)++;
    return queue[*front - 1];
}

struct Node* bt(struct Node* root, int data) {
    int front, rear;
    struct Node* n = (struct Node*)malloc(sizeof(struct Node));
    n->data = data;
    n->left = n->right = NULL;

    if (root == NULL) {
        return n;
    }

    struct Node** que = createqueue(&front, &rear);
    enqueue(que, &rear, root);

    while (front < rear) {
        struct Node* p = dequeue(que, &front);

        if (p->left == NULL) {
            p->left = n;
            break;
        } else {
            enqueue(que, &rear, p->left);
        }

        if (p->right == NULL) {
            p->right = n;
            break;
        } else {
            enqueue(que, &rear, p->right);
        }
    }

    free(que);
    return root;
}


struct Node* BST(struct Node* root,int data){
 
 if(root == NULL){
  struct Node* root = (struct Node*)malloc(sizeof(struct Node));
  root->data = data;
  root->left = root->right = NULL;
  return root;
 } 
 
 struct Node* temp =root;
 struct Node* prev;
 
 while(temp != NULL){
   prev = temp;
   
   if(data < temp->data){
     temp = temp->left;
   }else if(data > temp->data){
     temp = temp->right;
   }
 }
 
 struct Node* n = (struct Node*)malloc(sizeof(struct Node));
 n->data = data;
 n->left = n->right = NULL;
 
 
 if(data < prev->data){
   prev->left = n;
 }else{
   prev->right = n;
 }
 
 return root;
}

void inorder(struct Node* root) {
    struct stack *s = NULL;
    struct Node* temp = root;

    while (temp != NULL) {
        push(&s, temp);
        temp = temp->left;
    }

    while (s != NULL) {
        temp = pop(&s);
        printf("%d ", temp->data);
        temp = temp->right;

        while (temp != NULL) {
            push(&s, temp);
            temp = temp->left;
        }
    }
}

void postorder(struct Node* root){
  struct Node *temp = root;
  struct stack *s =NULL;
  struct Node* prev;
  
  while(temp != NULL){
    push(&s,temp);
    temp = temp->left;
  }
  
  while(s != NULL){
    temp = s->T;
    
    if(temp->right == NULL || temp->right == prev){
      printf("%d ",temp->data);
      pop(&s);
      prev =temp;
      temp = NULL;
    }else{
      temp = temp->right;
      while(temp != NULL){
        push(&s,temp);
        temp = temp->left;
      }
    }
  }
}



int heightofTree(struct Node* root) {
    if (root == NULL)
        return -1; 

    int rear, front;
    struct Node** que = createqueue(&front, &rear);
    enqueue(que, &rear, root);
    
    int height = -1; 

    while (front < rear) {
        int size = rear - front;
        height++;

        while (size > 0) {
            struct Node* temp = dequeue(que, &front);
            size--;

            if (temp->left != NULL)
                enqueue(que, &rear, temp->left);
            if (temp->right != NULL)
                enqueue(que, &rear, temp->right);
        }
    }

    return height;
}

struct Node* mirror(struct Node* root ){
    struct Node* temp = root;
    struct Node* curr;
    struct stack* s = NULL;

    push(&s,root);
    while(s != NULL){
        temp = pop(&s);
        curr = temp ->right;
        temp->right = temp ->left;
        temp->left = curr;

        if(temp->right != NULL){
            push(&s,temp->right);
        }

        if(temp->left != NULL){
            push(&s,temp->left);
        }
    }
    return root;
}


int main() {
    struct Node* root = NULL;

    // root = bt(root, 10);
    // root = bt(root, 20);
    // root = bt(root, 30);
    
    root = BST(root, 10);
    root = BST(root, 20);
    root = BST(root, 30);
    
    // mirror(root);
    inorder(root);
    // postorder(root);
    
    printf("height is :%d",heightofTree(root));

    return 0;
}




////   insert and delete in bst 

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct Stack {
    struct Node* node;
    struct Stack* next;
};

void Push(struct Stack** top, struct Node* temp) {
    struct Stack* s = (struct Stack*)malloc(sizeof(struct Stack));
    s->node = temp;
    s->next = (*top);
    (*top) = s;
}

struct Node* Pop(struct Stack** top) {
    if (*top == NULL) {
        return NULL;
    }
    struct Stack* temp = *top;
    *top = (*top)->next;
    struct Node* node = temp->node;
    free(temp);
    return node;
}

void preOrder(struct Node* root) {
    if (root == NULL) {
        return;
    }
    struct Stack* stack = NULL;
    struct Node* temp = root;
    
    while (temp != NULL || stack != NULL) {
        while (temp != NULL) {
            printf("%d ", temp->data);
            Push(&stack, temp);
            temp = temp->left;
        }
        temp = Pop(&stack);
        temp = temp->right;
    }
}




struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = data;
        node->left = node->right = NULL;
        return node;
    }

    struct Node* temp = root;
    struct Node* parent = NULL;

    while (temp != NULL) {
        parent = temp;
        if (data < temp->data) {
            temp = temp->left;
        } else {
            temp = temp->right;
        }
    }

    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->left = node->right = NULL;

    if (data < parent->data) {
        parent->left = node;
    } else {
        parent->right = node;
    }

    return root;
}

struct Node* findMin(struct Node* root) {
    while (root != NULL && root->left != NULL) {
        root = root->left;
    }
    return root;
}

struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL) {
        return NULL;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        struct Node* temp = findMin(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

int main() {
    struct Node* root = NULL;

    root = insert(root, 10);
    root = insert(root, 15);
    root = insert(root, 9);
    root = insert(root, 8);
    root = insert(root, 12);
    root = insert(root, 17);

    printf("Pre-Order Traversal: ");
    preOrder(root);
    printf("\n");

    root = deleteNode(root, 15);

    printf("Pre-Order Traversal after deletion: ");
    preOrder(root);
    printf("\n");

    return 0;
}



//levelorder height 





#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>


struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};




struct Node** createQueue(int*, int*);
void enqueue(struct Node**, int*, struct Node*);
struct Node* deQueue(struct Node**, int*);
bool isEmptyQ(struct Node**, int, int);
int heightofTree(struct Node*);










int heightofTree(struct Node* root) {
    if (root == NULL)
        return -1;


    int rear, front;
    struct Node** que = createQueue(&front, &rear);
    enqueue(que, &rear, root);
   
    int height = -1;


    while (!isEmptyQ(que, front, rear)) {
        int size = rear - front;
        height++;


        while (size > 0) {
            struct Node* temp = deQueue(que, &front);
            size--;


            if (temp->left != NULL)
                enqueue(que, &rear, temp->left);
            if (temp->right != NULL)
                enqueue(que, &rear, temp->right);
        }
    }


    return height;
}




bool isEmptyQ(struct Node** queue, int front, int rear) {
    return front == rear;
}


struct Node** createQueue(int* front, int* rear) {
    struct Node** queue = (struct Node**)malloc(500 * sizeof(struct Node*));
    *front = *rear = 0;
    return queue;
}




void enqueue(struct Node** queue, int* rear, struct Node* New_Node) {
    queue[*rear] = New_Node;
    (*rear)++;
}




struct Node* deQueue(struct Node** queue, int* front) {
    (*front)++;
    return queue[*front - 1];
}




struct Node* newNode(int data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return node;
}


void printLvlOrder(struct Node* root){
    int rear;
    int front;
    struct Node** queue = createQueue(&front,&rear);
    struct Node* temp_node = root;
   
    while(front <= rear){


        printf("%d ",temp_node->data);
       
        if(temp_node->left){
            enqueue(queue,&rear,temp_node->left);
        }


        if(temp_node->right){
            enqueue(queue,&rear,temp_node->right);
        }
       
        temp_node = deQueue(queue,&front);


    }
}


void leafNodes(struct Node* root){
    if(root==NULL){
        return;
    }
    int rear , front;
    struct Node** q = createQueue(&front,&rear);
    enqueue(q,&rear,root);


    while(!isEmptyQ(q,front,rear)){
        struct Node * temp = deQueue(q,&front);


        if(temp->left == NULL && temp->right == NULL){
            printf("%d ",temp->data);
        }


        if(temp->left != NULL){
            enqueue(q,&rear,temp->left);
        }
        if(temp->right != NULL){
            enqueue(q,&rear,temp->right);
        }
    }
}






int main() {
    struct Node* root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->left = newNode(4);
    root->left->right = newNode(5);
    root->left->right->left =  newNode(8);
   
    printf("Height of the tree: %d\n", heightofTree(root));
    printf("leveOrder is :");
    printLvlOrder(root);
    printf("\n");
    printf("leaf Nodes:");
    leafNodes(root);
    return 0;
}












//-------------------------------------------------------------------------------------------------------------














// #include<stdio.h>
// #include<stdlib.h>


// struct Node {
//     int data;
//     struct Node* left;
//     struct Node* right;
// };


// void lvlOrder(struct Node* root) {
//     if(root == NULL) {
//         return;
//     }


//     struct Node **queue = (struct Node **)malloc(sizeof(struct Node*) * 100);


//     int front = 0, rear = -1;


//     queue[++rear] = root;


//     while(front <= rear) {
//         struct Node* curr = queue[front++];


//         if(curr == NULL) {
//             if(front == rear+1) {
//                 break;
//             } else {
//                 queue[++rear] = NULL;
//             }
//         } else {
//             printf("%d ", curr->data);
//             if(curr->left != NULL) {
//                 queue[++rear] = curr->left;
//             }
//             if(curr->right != NULL) {
//                 queue[++rear] = curr->right;
//             }
//         }
//     }


//     free(queue);
// }




// int main() {
 
//     struct Node* root = (struct Node*)malloc(sizeof(struct Node));
//     root->data = 1;
//     root->left = (struct Node*)malloc(sizeof(struct Node));
//     root->left->data = 2;
//     root->right = (struct Node*)malloc(sizeof(struct Node));
//     root->right->data = 3;
//     root->left->left = NULL;
//     root->left->right = NULL;
//     root->right->left = (struct Node*)malloc(sizeof(struct Node));
//     root->right->left->data = 4;
//     root->right->right = NULL;
//     root->right->left->left = NULL;
//     root->right->left->right = NULL;




//     lvlOrder(root);




//     return 0;
// }



//// heap quick : 




#include <stdio.h>
#include <stdlib.h>

struct employee {
    int id;
    char name[20];
    int salary;
};

int partition(struct employee arr[], int low, int high) {
    int i = low + 1;
    int j = high;

    int pivot = arr[low].id;

    do {
        while (arr[i].id < pivot && i < high) {
            i++;
        }
        while (arr[j].id > pivot) {
            j--;
        }

        if (i < j) {
            struct employee temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

    } while (i < j);

    struct employee temp = arr[low];
    arr[low] = arr[j];
    arr[j] = temp;

    return j;
}

void quickSort(struct employee arr[], int low, int high) {
    int j;
    if (low < high) {
        j = partition(arr, low, high);
        quickSort(arr, low, j - 1);
        quickSort(arr, j + 1, high);
    }
}

void swap(struct employee *a, struct employee *b) {
    struct employee temp = *a;
    *a = *b;
    *b = temp;
}

void createMaxHeap(struct employee arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left].id > arr[largest].id) {
        largest = left;
    }
    if (right < n && arr[right].id > arr[largest].id) {
        largest = right;
    }
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        createMaxHeap(arr, n, largest);
    }
}

void heapSort(struct employee arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        createMaxHeap(arr, n, i);
    }

    for (int i = n - 1; i >= 0; i--) {
        swap(&arr[0], &arr[i]);
        createMaxHeap(arr, i, 0);
    }
}

int main() {
    int size;
    scanf("%d", &size);

    struct employee arr[size];

    for (int i = 0; i < size; i++) {
        scanf("%d", &arr[i].id);
        scanf("%s", arr[i].name); // no & for strings
        scanf("%d", &arr[i].salary);
    }

    // quickSort(arr, 0, size - 1);
    heapSort(arr, size);

    for (int i = 0; i < size; i++) {
        printf("Name : %s | id. : %d | salary : %d\n", arr[i].name, arr[i].id, arr[i].salary);
    }

    return 0;
}


All using matrix


#include <stdio.h>
#include <stdlib.h>

int parent[10]; 

int findMin(int visited[], int dist[], int v) {
    int min = 999, idx = 0;
    for (int i = 0; i < v; i++) {
        if (visited[i] == 0 && dist[i] < min) {
            min = dist[i];
            idx = i;
        }
    }
    return idx;
}

void display(int parent[], int v) {
    for (int i = 1; i < v; i++) {
        printf("%d -> %d\n", parent[i], i);
    }
}

void prims(int G[10][10], int v) {
    int dist[v];
    int visited[v];

    for (int i = 0; i < v; i++) {
        parent[i] = -1;
        dist[i] = 999;
        visited[i] = 0;
    }

    int st;
    scanf("%d", &st);
    dist[st] = 0;

    for (int i = 0; i < v - 1; i++) {
        int u = findMin(visited, dist, v);
        visited[u] = 1;

        for (int j = 0; j < v; j++) {
            if (G[u][j] && visited[j] == 0 && G[u][j] < dist[j]) {
                dist[j] = G[u][j];
                parent[j] = u;
            }
        }
    }

    display(parent, v);
}

int findparent(int parent[], int i) {
    while (i != parent[i]) {
        i = parent[i];
    }
    return i;
}

void uni(int i, int j, int parent[]) {
    int a = findparent(parent, i);
    int b = findparent(parent, j);
    parent[b] = a;
}

void krushkals(int G[10][10], int v) {
    int ne = 0;
    int a, b;

    for (int i = 0; i < v; i++) {
        parent[i] = i;
    }

    while (ne < v - 1) {
        int min = 999; 
        for (int i = 0; i < v; i++) {
            for (int j = 0; j < v; j++) {
                if (G[i][j] && G[i][j] < min && findparent(parent, i) != findparent(parent, j)) {
                    min = G[i][j];
                    a = i;
                    b = j;
                }
            }
        }
        uni(a, b, parent);
        printf("edge %d :- %d %d => %d\n", ne++, a, b, min);
    }
}

void display1(int dist[],int start,int v){
    for(int i=0;i<v;i++){
        printf("distance from %d to %d is %d\n",start,i,dist[i]);
    }
}

void djk(int G[10][10],int v) {
    int visited[v];
    int dist[v];
    for(int i = 0; i<v; i++) {
        visited[i] = 0;
        dist[i] = 999;
    }
    int st;
    scanf("%d",&st);
    dist[st] = 0;
    for(int i=0; i<v-1; i++) {
        int z = findMin(visited,dist,v);
        visited[z] = 1;
        for(int j= 0; j<v; j++) {
            if(visited[j] == 0 && dist[j] > dist[z]+G[z][j]) {
                dist[j] = dist[z]+G[z][j];
            }
        }
    }
    display1(dist,st,v);
}

int main() {
    int v, numed;
    int G[10][10];

    scanf("%d", &v);
    scanf("%d", &numed);

    for (int i = 0; i < v; i++) {
        for (int j = 0; j < v; j++) {
            G[i][j] = 0;
        }
    }

    for (int i = 0; i < numed; i++) {
        int u, w, z;
        scanf("%d %d %d", &u, &w, &z);
        G[u][w] = G[w][u] = z;
    }


    // prims(G, v);
    // krushkals(G, v);
    djk(G, v);

    return 0;
}




////////polyadd

#include<stdio.h>
#include<stdlib.h>


struct poly{
    int coeff;
    int exp;
    struct poly* next;
};
struct poly* createList(int n){
    struct poly *polynomial = NULL;
    struct poly *temp;
    struct poly *last;
    for(int i = 0; i < n; i++){
        temp = (struct poly*)malloc(sizeof(struct poly));
        scanf("%d %d", &(temp->coeff), &(temp->exp));
        temp->next = NULL;

        if(polynomial == NULL){
            polynomial = temp;
            last = temp;
        } else {
            last->next = temp;
            last = temp;
        }
    }
    return polynomial;
}


void printPolynomial(struct poly *polynomial){
    while (polynomial != NULL){
        printf("%dx^%d", polynomial->coeff, polynomial->exp);
        polynomial = polynomial->next;
        if (polynomial != NULL){
            printf(" + ");
        }
    }
    printf("\n");
}

// Function to add two polynomial linked lists
struct poly* add(struct poly* p1, struct poly* p2){
    struct poly* poly3 = NULL;
    struct poly* p3 = NULL;
    struct poly* temp = NULL;

    while (p1 != NULL && p2 != NULL) {
        temp = (struct poly*)malloc(sizeof(struct poly));
        temp->next = NULL;

        if (poly3 == NULL) {
            poly3 = temp;
            p3 = temp;
        } else {
            p3->next = temp;
            p3 = temp;
        }

        if (p1->exp == p2->exp) {
            p3->exp = p1->exp;
            p3->coeff = p1->coeff + p2->coeff;
            p1 = p1->next;
            p2 = p2->next;
        } else if (p1->exp > p2->exp) {
            p3->exp = p1->exp;
            p3->coeff = p1->coeff;
            p1 = p1->next;
        } else {
            p3->exp = p2->exp;
            p3->coeff = p2->coeff;
            p2 = p2->next;
        }
    }

    while (p1 != NULL) {
        temp = (struct poly*)malloc(sizeof(struct poly));
        temp->next = NULL;

        if (poly3 == NULL) {
            poly3 = temp;
            p3 = temp;
        } else {
            p3->next = temp;
            p3 = temp;
        }

        p3->exp = p1->exp;
        p3->coeff = p1->coeff;
        p1 = p1->next;
    }

    while (p2 != NULL) {
        temp = (struct poly*)malloc(sizeof(struct poly));
        temp->next = NULL;

        if (poly3 == NULL) {
            poly3 = temp;
            p3 = temp;
        } else {
            p3->next = temp;
            p3 = temp;
        }

        p3->exp = p2->exp;
        p3->coeff = p2->coeff;
        p2 = p2->next;
    }

    return poly3;
}

int main() {
    struct poly* list1 = createList(2);
    struct poly* list2 = createList(2);
    struct poly* res = add(list1, list2);

    printPolynomial(list1);
    printPolynomial(list2);
    printPolynomial(res);

    return 0;
}



///infix postfix and all


#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>

char stack[100];
int top = -1;

void push(char ch){
  top++;
  stack[top] = ch;
}

char pop(){
  
  return stack[top--];
  
}

int precedence(char op){
  
  if(op == '+' || op == '-'){
  
    return 1;
  }else if(op == '*' || op == '/'){
    return 2;
  }else if(op == '^'){
    return 3;
  }else{
    return 0;
  }
}

int isoprand(char ch){
  return isalnum(ch);
}

int isoprator(char ch)
{
    return ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^';
}

void infix_to_postfix(char infix[],char postfix[]){
  
  int j = 0;
  
  for(int i=0;infix[i] != '\0';i++){
    
    char ch = infix[i];
    
    if(isoprand(ch))
    {
      postfix[j] = ch;
      j++;
    }else if(isoprator(ch)){
      while( top != -1 && precedence(ch) <= precedence(stack[top]) ){
        postfix[j] = pop();
        j++;
      }
      push(ch);
    }else if(ch == '('){
      push(ch);
    }else if(ch ==')'){
      while(stack[top] != '('){
        postfix[j] = pop();
        j++;
      }
      pop();
    }
  }
  
  while(top != -1){
    postfix[j] = pop();
    j++;
  }
  postfix[j] = '\0';
}

int main(){
  char infix[100];
  char postfix[100];
  
  scanf("%s",&infix);
  
  infix_to_postfix(infix,postfix);
  
  printf("%s\n",postfix);
}



//// dfs matrix 

#include <stdio.h>
#include<stdlib.h>


struct stack{
  int data;
  struct stack* next;
};

void push(struct stack** top,int data){
  struct stack *s = (struct stack*)malloc(sizeof(struct stack));
  
  s->data = data;
  s->next = *top;
  (*top )= s;
  
}

int pop(struct stack **top){
  struct stack *temp = *top;
  *top = (*top)->next;
  int val = temp->data;
  return val;
  
}



void dfsmat(int G[][10],int v){
  
  struct stack *s = NULL;
  int visited[10];
  for(int i=0;i<v;i++){
    visited[i] = 0;
  }
  int start;
  scanf("%d",&start);
    visited[start] = 1;
  push(&s,start);
  
  // printf("%d ",start);

  
  while(s != 0){
    int u = pop(&s);
    printf("%d ",u);
    
    for(int i=0;i<v;i++){
      if(G[u][i] == 1 && visited[i] == 0){
        push(&s,i);
        visited[i] = 1;
      }
    }
  }
}




int main()
{

int v,u,w;
scanf("%d",&v);


int G[10][10];

for(int i=0;i<v;i++){
  for(int j=0;j<v;j++){
    G[i][j] = 0;
  }
}


int numed;
  scanf("%d",&numed);
for(int i=0;i<numed;i++){
  
  scanf("%d %d",&u,&w);
  
  G[u][w] = G[w][u] = 1;
  
  
}

dfsmat(G,v);
}







/// dfs using list


#include <stdio.h>
#include <stdlib.h>

struct Node {
    int vertex;
    struct Node* next;
};

struct stack {
    int cap;
    int top;
    int* arr;
};

struct stack* createStack(int cap) {
    struct stack* s = (struct stack*)malloc(sizeof(struct stack));
    s->cap = cap;
    s->top = -1;
    s->arr = (int*)malloc(cap * sizeof(int));
    return s;
}

void push(struct stack* s, int val) {
    if (s->top < s->cap - 1) {
        s->arr[++(s->top)] = val;
    } else {
        printf("Stack overflow\n");
    }
}

int pop(struct stack* s) {
    if (s->top >= 0) {
        return s->arr[(s->top)--];
    } else {
        printf("Stack underflow\n");
        return -1;
    }
}

int isEmpty(struct stack* s) {
    return s->top == -1;
}

void adjList(struct Node* A[], int v) {
    int u, w;
    struct Node* newN;

    for (int i = 0; i < v; i++) {
        A[i] = NULL;
    }

    int numed;
    printf("Enter number of edges: ");
    scanf("%d", &numed);

    for (int i = 0; i < numed; i++) {
        printf("Enter edge (S -> D): ");
        scanf("%d %d", &u, &w);

        newN = (struct Node*)malloc(sizeof(struct Node));
        newN->vertex = w;
        newN->next = A[u];
        A[u] = newN;

        newN = (struct Node*)malloc(sizeof(struct Node));
        newN->vertex = u;
        newN->next = A[w];
        A[w] = newN;
    }
}

void dfs(struct Node* A[], int v) {
    int visited[v];
    int start;
    struct Node* temp;
    struct stack* s = createStack(20);

    printf("Enter start vertex: ");
    scanf("%d", &start);

    for (int i = 0; i < v; i++) {
        visited[i] = 0;
    }

    visited[start] = 1;
    push(s, start);

    while (!isEmpty(s)) {
        int w = pop(s);
        printf("%d ", w);
        temp = A[w];
        while (temp != NULL) {
            int n = temp->vertex;
            if (visited[n] == 0) {
                push(s, n);
                visited[n] = 1;
            }
            temp = temp->next;
        }
    }
}

int main() {
    int v;
    printf("Enter number of vertices: ");
    scanf("%d", &v);

    struct Node* A[v];
    adjList(A, v);

    dfs(A, v);

    return 0;
}



///bfs list


 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>

 struct Node {
     int vertex;
     struct Node* next;
 };

 void bfsList(struct Node** G, int v) {
    int visited[10];
    int st, w;

    printf("Enter start vertex: ");
    scanf("%d", &st);

    int *queue = (int *)malloc(sizeof(int) * 100);
    int front = 0, rear = -1;
    queue[++rear] = st;

    for (int i = 0; i < v; i++) {
        visited[i] = 0;
    }
    visited[st] = 1;

    while (front <= rear) {
        w = queue[front++];
        printf("%d ", w);

        struct Node* p = G[w];

        while (p != NULL) {
            if (visited[p->vertex] == 0) {
                queue[++rear] = p->vertex;
                visited[p->vertex] = 1;
            }
            p = p->next;
        }
    }
}

void AdjList(struct Node* A[], int v) {
    int u, w;
    char ch[4];

    struct Node* p;
    struct Node* newV;

    for (int i = 0; i < v; i++) {
        A[i] = NULL;
    }
                                                                                                     
    do {
        printf("Enter edge (source destination): ");
        scanf("%d %d", &u, &w);

        newV = (struct Node*)malloc(sizeof(struct Node));
        newV->vertex = w;
        newV->next = NULL;

        p = A[u];
        if (p == NULL) {
            A[u] = newV;
        } else {
            while (p->next != NULL) {
                p = p->next;
            }
            p->next = newV;
        }

        newV = (struct Node*)malloc(sizeof(struct Node));
        newV->vertex = u;
        newV->next = NULL;

        p = A[w];
        if (p == NULL) {
            A[w] = newV;
        } else {
            while (p->next != NULL) {
                p = p->next;
            }
            p->next = newV;
        }

        printf("Do you want to continue adding edges? (yes/no): ");
        scanf("%s", ch);
    } while (strcmp(ch, "yes") == 0);
}

int main() {
    struct Node* G[10];
    int v;

    printf("Enter number of vertices: ");
    scanf("%d", &v);

    AdjList(G, v);
    bfsList(G, v);

    return 0;
 }



//// circulardeque:

#include <stdio.h>
#include <stdlib.h>

struct circQue {
    int f;
    int r;
    int size;
    int *arr;
};

int isFull(struct circQue *q) {
    return (q->r + 1) % q->size == q->f;
}

int isEmpty(struct circQue *q) {
    return q->f == -1;
}

void enqueue(struct circQue *q, int val) {
    if (isFull(q)) {
        printf("Queue is full\n");
        return;
    }

    if (isEmpty(q)) {
        q->f = q->r = 0;
    } else {
        q->r = (q->r + 1) % q->size;
    }

    q->arr[q->r] = val;
}

void deque(struct circQue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return;
    }

    int val = q->arr[q->f];
    if (q->f == q->r) {
        q->f = q->r = -1;
    } else {
        q->f = (q->f + 1) % q->size;
    }

    printf("dequed: %d\n", val);
}

void addfront(struct circQue *q, int val) {
    if (isFull(q)) {
        printf("Queue is full\n");
        return;
    }

    if (isEmpty(q)) {
        q->f = q->r = 0;
    } else {
        q->f = (q->f - 1 + q->size) % q->size;
    }

    q->arr[q->f] = val;
}

void removeRear(struct circQue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return;
    }

    int val = q->arr[q->r];
    if (q->f == q->r) {
        q->f = q->r = -1;
    } else {
        q->r = (q->r - 1 + q->size) % q->size;
    }

    printf("removed from rear: %d\n", val);
}

void printQueue(struct circQue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return;
    }

    printf("Queue: ");
    int i = q->f;
    while (i != q->r) {
        printf("%d ", q->arr[i]);
        i = (i + 1) % q->size;
    }
    printf("%d\n", q->arr[i]);  
}

int main() {
    struct circQue *que = (struct circQue *)malloc(sizeof(struct circQue));
    que->f = -1;
    que->r = -1;
    que->size = 10;
    que->arr = (int *)malloc(que->size * sizeof(int));

    enqueue(que, 10);
    enqueue(que, 20);
    enqueue(que, 30);
    printQueue(que);  
    addfront(que, 5);
    printQueue(que);  
    deque(que);
    printQueue(que);  
    deque(que);
    printQueue(que);  
    removeRear(que);
    printQueue(que);  
    removeRear(que);
    printQueue(que);  

    free(que->arr);
    free(que);

    return 0;
}



///factorial
#include <stdio.h>
#include <stdlib.h>

#define MAX 10

struct stack {
    int *arr;
    int top;
};

void initialize(struct stack *s, int size) {
    s->arr = (int *)malloc(size * sizeof(int));
    s->top = 0;
}

void push(struct stack* s, int val) {
    if (s->top >= MAX) {
        printf("Stack overflow\n");
        return;
    }
    s->arr[s->top++] = val;
}

int pop(struct stack* s) {
    if (s->top <= 0) {
        printf("Stack underflow\n");
        return -1; 
    }
    return s->arr[--(s->top)];
}

int isEmpty(struct stack* s) {
    return s->top == 0;
}

int main() {
    struct stack *s = (struct stack *)malloc(sizeof(struct stack));
    initialize(s, MAX);
    int product = 1;

    for(int i = 1; i <= 5; i++){
        push(s, i);
    }

    while(!isEmpty(s)){
        int v = pop(s);
        if (v != -1) {  
            product *= v;
        }
    }
    
    printf("Product: %d\n", product);

    
    free(s->arr);
    free(s);

    return 0;
}


///merge doubly linked list:

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createList(int n){
    struct Node* list = NULL,*temp,*last;
     
     for(int i=0;i<n;i++){
        temp = (struct Node* )malloc(sizeof(struct Node));
        printf("Enter the element");
        scanf("%d",&temp->data);

        temp->next = NULL;
        temp->prev = NULL;

        if(list == NULL){
            list = temp;
            last = temp;

        }else{
            last->next = temp;
            last = temp;
        }
    }
    return list;


}






void Print(struct Node * list){
    while(list != NULL){
        printf("%d ",list->data);
        list=list->next;
    }
     printf("\n");
   
}



void appendDll(struct Node* a ,struct Node* b){
    if(a == NULL){
        a == b;
    }else{

        while(a->next != NULL){
            a = a->next;
        }
        a->next = b;
        b->prev = a;
    }
    b=NULL;
}



int main(){

    struct Node* list1;
    struct Node* list2;
    int n1,n2;
    printf("enter number of nodes for list one and two");
    scanf("%d %d",&n1,&n2);
    
    list1 = createList(n1);
    list2 = createList(n2);
    appendDll(list1,list2);
    Print(list1);

    return 0;

}




///// employee id

// // Write a program to efficiently search a particular employee record by using Tree data structure.
// // Also sort the data on emp-id in ascending order.

// #include <stdio.h>
// #include <stdlib.h>

// struct node
// {
//     int empId;
//     struct node *left, *right;
// };

// struct node *BST(struct node *root, int     id)
// {
//     if (root == NULL)
//     {
//         root = (struct node *)malloc(sizeof(struct node));
//         root->empId = id;
//         root->left = root->right = NULL;
//         return root;
//     }

//     struct node *temp = root, *pre;
//     while (temp != NULL)
//     {
//         pre = temp;
//         if (id == temp->empId)
//         {
//             return root;
//         }
//         else if (id < temp->empId)
//         {
//             temp = temp->left;
//         }
//         else if (id > temp->empId)
//         {
//             temp = temp->right;
//         }
//     }

//     struct node *n = (struct node *)malloc(sizeof(struct node));
//     n->empId = id;
//     n->left = n->right = NULL;

//     if (id < pre->empId)
//     {
//         pre->left = n;
//     }
//     else if (id > pre->empId)
//     {
//         pre->right = n;
//     }

//     return root;
// }

// void inOrder(struct node *root)
// {
//     if (root != NULL)
//     {
//         inOrder(root->left);
//         printf("%d ", root->empId);
//         inOrder(root->right);
//     }
// }

// void main()
// {
//     struct node *root = NULL;
//     root = BST(root, 23);
//     root = BST(root, 28);
//     root = BST(root, 21);
//     root = BST(root, 27);
//     root = BST(root, 74);
//     root = BST(root, 11);
//     root = BST(root, 60);

//     inOrder(root);
// }



//// two stack : 

void push(int *stack,int val,int *top1){

stack[++(*top1)] = val;
printf("added %d at %d \n",stack[(*top1)-1],*top1);
}

void pop(int *stack,int *top1){
    stack[(*top1)]=NULL;
    stack[(*top1)--];

}

int main(){

    int *stack=(int *)malloc(sizeof(int)*10);

    int top1 = -1;

    int top2 = 4;

    push(stack,10,&top1);
    push(stack,20,&top1);
    push(stack,30,&top1);
    push(stack,40,&top1);
    pop(stack,&top1);
    push(stack,60,&top2);
    push(stack,70,&top2);
    push(stack,80,&top2);
    push(stack,90,&top2);
    printf("\n");
    for(int i=0 ;i<10;i++){
        printf("%d\n",stack[i]);
    }

}



/////  linkedlist reverse 
#include <stdio.h>
#include <stdlib.h>

struct Node
{
    int data;
    struct Node *next;
};

//insert start
void insert(struct Node **headref, int data)
{
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = data;
    new_node->next = *headref;
    *headref = new_node;
}

//insert end
void insert_end(struct Node **headref,int data){
    struct Node *new = (struct Node *)malloc(sizeof(struct Node));
    struct Node *temp = *headref;
    new->data =data;
    new->next = NULL;
    while(temp->next != NULL){
    temp=temp->next;
    }
    temp->next = new;
    new->next = NULL;
}


void insert_at_node(struct Node **headref,int data,int index){
int count = 0;
struct Node *new = (struct Node *)malloc(sizeof(struct Node));
struct Node *temp = *headref;
new->data = data;
while(count < index-1){
    count++;
    temp = temp->next;
}
new->next = temp->next;
temp->next = new;

}


void printll(struct Node *head)
{
    struct Node *temp = head;

    while (temp != NULL)
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }
}


void reversell(struct Node **headref){
    struct Node* prev = NULL;
    struct Node* curr = *headref;
    struct Node* next = NULL;

    while(curr != NULL){
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr=next;
    }
    *headref = prev;
}

void printmiddle(struct Node** headref) {
    struct Node* fast = *headref;
    struct Node* slow = *headref;
    struct Node* prev_slow = NULL;

    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        prev_slow = slow;
        slow = slow->next;
    }

    if (prev_slow != NULL) {
        printf("middles of the list are : %d %d ", prev_slow->data, slow->data);
    } else {
        printf(" middle of list is : %d ", slow->data);
    }
}

int loopDetect(struct Node** headref){
    struct Node* slow = *headref;
    struct Node* fast = *headref;
    while(fast -> next && fast->next->next){
        slow = slow -> next;
        fast = fast->next->next;
        if(slow==fast){
            printf("loop found\n");
            return 1;
        }
    }
    printf("loop not found\n");
   return 0;
}


int main(){
    struct Node *head = NULL;

    insert(&head,20);
    insert(&head,50);
    insert(&head,70);
    insert(&head,80);
    insert(&head,90);
    insert(&head,99);
    insert_end(&head,100);
    insert_end(&head,102);
    insert_at_node(&head,5,3);
    createloop(&head);
    loopDetect(&head);

    printf("original :");
    printll(head);
    printf("\n");
    reversell(&head);
    printf("reversed :");
    printll(head);
    printf("\n");
    printmiddle(&head);
}



//// graph algos 


Dfs mat 

#include<stdio.h>
#include<stdlib.h>


int FindMin(int dist[], int visited[], int v) {
    int index, min = 999;

    for (int i = 0; i < v; i++) {
        if (visited[i] == 0 && min > dist[i]) {
            min = dist[i];
            index = i;
        }
    }
    return index;
}


void DisplayMst(int parent[], int G[][10], int v
) {
    printf("Edges in Minimum Spanning Tree:\n");
    for (int i = 1; i < v; i++) {
        printf("%d - %d\n", parent[i], i);
    }
}


void prims(int G[][10], int v) {
    int visited[10];
    int parent[10];
    int dist[10];

    for (int i = 0; i < v; i++) {
        parent[i] = -1;
        visited[i] = 0;
        dist[i] = 999;
    }

    dist[0] = 0;

    for (int i = 0; i < v - 1; i++) {
        int u = FindMin(dist, visited, v); 
        visited[u] = 1;

        for (int j = 0; j < v; j++) {
            if (visited[j] == 0 && G[u][j] && G[u][j] < dist[j]) {
                dist[j] = G[u][j];
                parent[j] = u;
            }
        }
    }

    DisplayMst(parent, G, v); 
}


int main() {
    int v;
    printf("Enter number of vertices: ");
    scanf("%d", &v);
    int G[10][10]; 
    int u, w, z, numEdges;

    for (int i = 0; i < v; i++) {
        for (int j = 0; j < v; j++) { 
            G[i][j] = 0;
        }
    }

    for (int i = 0; i < v; i++) {
        printf("Enter number of edges for vertex %d: ", i);
        scanf("%d", &numEdges);
        for (int j = 0; j < numEdges; j++) {
            printf("Enter edge (source destination)and weight ");
            scanf("%d %d %d", &u, &w ,&z);
            G[u][w] = G[w][u] = z ;
        }
    }
    prims(G, v); 
    return 0;
}



///primslist:

#include<stdio.h>
#include<stdlib.h>

struct Node{
    int vertex;
    int wt;
    struct Node* next;
};

struct graph{
    int V;
    struct Node ** Array;
};

struct Node *newNode(int data,int w){
    struct Node * new =(struct Node*)malloc(sizeof(struct Node));
    new->vertex = data;
    new->wt = w;
    new->next=NULL;
    return new;
}

struct graph *create(int v){
    struct graph* g =(struct graph*)malloc(sizeof(struct graph));
    g->V = v;
    g->Array = (struct Node **)malloc(v* sizeof(struct Node *)); 

    for(int i=0;i<v;i++){
        g->Array[i] = NULL;
    }
    return g;
}

void AdjList(struct graph* g, int V)
{
    int e, u, v, w; 
    struct Node* p ;
    struct Node* newN;
    printf("enter number of edges: ");
    scanf("%d",&e);
    for(int i=0;i<e;i++){
        printf("enter edges and weight: ");
        scanf("%d %d %d",&u,&v,&w); 

        newN = newNode(v,w); 
        p = g->Array[u];
        if(p == NULL){
            g->Array[u] = newN;
        }else{
            while(p->next != NULL){
                p = p->next;
            }
            p->next = newN;
        }


        newN = newNode(u,w); 
        p = g -> Array[v];
        if(p == NULL){
            g->Array[v] = newN;
        }else{
            while(p->next != NULL){
              p = p->next;
            }
            p->next = newN;
        }
    }
}


void display(struct graph* g){
    for(int i=0;i<g->V;i++){
        struct Node *p =g->Array[i];
        printf("%d |",i);
        while(p != NULL){
            printf("%d ->",p->vertex);
            p = p->next;
        }
        printf("\n");
    }
}


int FindMin(int dist[],int visited[],int v){
    int index, min = 999;

    for(int i=0;i<v;i++){
        if(visited[i] == 0 && min > dist[i]){
            min  = dist[i]; 
            index = i;
        }
    }
    return index;
}


void prims(struct graph* g,int v) {
    int visited[10];
    int parent[10];
    int dist[10];

    for(int i=0;i<v;i++){
        parent[i] = -1;
        visited[i] = 0;
        dist[i] = 999;
    }
    dist[0] = 0;

    for(int i=0;i< v-1;i++){
        int u = FindMin(dist,visited,v);
        visited[u] = 1;
        struct Node* p = g->Array[u];
        while(p != NULL){
            if(visited[p->vertex] == 0 && p->wt < dist[p->vertex]){
                dist[p->vertex] = p->wt;
                parent[p->vertex] = u;
            }
            p = p->next;
        }

    }
    printf("Edges in Minimum Spanning Tree:\n");
    for (int i = 1; i < v; i++) {
        printf("%d - %d\n", parent[i], i);
    }
}



int main(){
    int v;
    printf("enter number of vertices: ");
    scanf("%d",&v);
    struct graph *g = create(v);
    AdjList(g,v);
    prims(g, v);
    return 0;
}


///krushkals mat 

#include<stdio.h>
#include<stdlib.h>

#define MAX 10

int parent[MAX]; 

int findparent(int i){
    while(i != parent[i]){
        i = parent[i];
    }
    return i;
}

void uni(int i , int j){
    int a = findparent(i);
    int b = findparent(j);
    parent[b]= a;
}

void krushkals(int G[][MAX],int v){

    int ne = 0;
    int a, b; 

    for(int i=0;i<v;i++){
        parent[i] = i;
    }

    while(ne < v-1){

        int min = 999; 

        for(int i=0;i<v;i++){
            for(int j=0;j<v;j++){
                if(G[i][j] != 0 && G[i][j] < min && findparent(i) != findparent(j)){
                    min = G[i][j];
                    a = i;
                    b = j;
                }
            }
        }

        uni(a,b);

        printf("Edge %d :- %d %d => %d\n", ne++, a, b, min);
    }
}

int main() {
    int v;
    printf("Enter number of vertices: ");
    scanf("%d", &v);
    int G[MAX][MAX]; 
    int u, w, z, numEdges;

    for (int i = 0; i < v; i++) {
        for (int j = 0; j < v; j++) { 
            G[i][j] = 0;
        }
    }

    for (int i = 0; i < v; i++) {
        printf("Enter number of edges for vertex %d: ", i);
        scanf("%d", &numEdges);
        for (int j = 0; j < numEdges; j++) {
            printf("Enter edge (source destination) and weight: ");
            scanf("%d %d %d", &u, &w, &z);
            G[u][w] = G[w][u] = z ;
        }
    }
    krushkals(G, v); 
    return 0;
}

///krushkals list ;
#include<stdio.h>
#include<stdlib.h>
struct Node {
    int vertex;
    int wt;
    struct Node* next;
};

struct graph{
int V;
struct Node **Array;
};


 
struct Node *newNode(int data,int w){
    struct Node * new = (struct Node*)malloc(sizeof(struct Node));
    new->vertex = data;
    new->wt = w;
    new->next=NULL;
    return new;
}

struct graph * create(int v){
    struct graph* g = (struct graph*)malloc(sizeof(struct Node) * v);
    g->V = v;
    g->Array = (struct Node**)malloc(v* (sizeof(struct Node)));
    for(int i=0;i<v;i++){
        g->Array[i] = NULL;
    } 
    return g;
}

void AdjList(struct graph* g,int V){
    int e,u,v,w;
    struct Node* p;
    struct Node* newN;
    printf("enter number of edges");
    scanf("%d",&e);
    for(int i=0;i<e;i++){
        printf("enter edge and weight:");
        scanf("%d %d %d",u,v,w);

        newN = newNode(u,w);
        p = g->Array[v];
        if(p == NULL){
            g->Array[v] = newN;
        }else{
            while(p->next != NULL){
                p = p->next;
            }
            p->next = newN;
        }
        
        newN = newNode(v,w);
        p = g->Array[u];
        if(p == NULL){
            g->Array[u] = newN;
        }else{
            while(p->next != NULL){
                p = p->next;
            }
            p->next = newN;
        }


    }
}


void display(struct graph* g){
    for(int i=0;i<g->V;i++){
        struct Node *p =g->Array[i];
        printf("%d |",i);
        while(p != NULL){
            printf("%d ->",p->vertex);
            p = p->next;
        }
        printf("\n");
    }
}


int findParent(int i,int parent[]){
    while(i != parent[i]){
        i = parent[i];
    }
    return i;
}

void uni(int i,int j,int parent[]){
    int a = findParent(i,parent);
    int b = findParent(j,parent);
    parent[b] = a;
}



void krushkals(struct graph *g,int v,int parent[]){
    int min,a,b,ne=0,minWeight = 0;
    while(ne < v-1){
        min = 999;
        for(int i=0;i<v;i++){
            struct Node *p = g->Array[i];
            while(p != NULL){
                if(p->wt < min && findParent(p->vertex,parent) != findParent(i,parent)){
                    min = p->wt;
                    a = i;
                    b = p->vertex;
                }
                p = p->next;
            }
        }
        uni(a,b,parent);

        printf("%d %d => %d\n",a,b,min);
        ne++;
        minWeight += min;
    }
}


void main(){
    int v;
    printf("enter number of vertices");
    scanf("%d",&v);
    struct graph *g = create(v);
    AdjList(g,v);
    display(g);

    int parent[v+1];
    for(int i=0;i<=v;i++){
        parent[i] = i;
    }
    printf("\n\n\n");
    krushkals(g,v,parent);
}




/// dijikstas mat 

#include <stdio.h>
#include <stdlib.h>

void display(int dist[], int start, int v) {
    for (int i = 0; i < v; i++) {
        printf("Distance from %d to %d is %d\n", start, i, dist[i]);
    }
}

int minVertex(int dist[], int visited[], int v) {
    int minimum = 9999;
    int idx;
    for (int i = 0; i < v; i++) {
        if (visited[i] == 0 && dist[i] < minimum) {
            minimum = dist[i];
            idx = i;
        }
    }
    return idx;
}

void dijkstras(int v, int G[v][v], int startVertex) {
    int visited[v];
    int dist[v];

    for (int i = 0; i < v; i++) {
        dist[i] = 999;
        visited[i] = 0;
    }

    dist[startVertex] = 0;

    for (int i = 0; i < v - 1; i++) {
        int f = minVertex(dist, visited, v);
        visited[f] = 1;

        for (int j = 0; j < v; j++) {
            if (visited[j] == 0 && dist[j] > dist[f] + G[f][j]) {
                dist[j] = dist[f] + G[f][j];
            }
        }
    }

    display(dist, startVertex, v);
}

int main() {
    int v, u, x, wt;
    printf("Enter number of vertices: ");
    scanf("%d", &v);
    int G[v][v];

    for (int i = 0; i < v; i++) {
        for (int j = 0; j < v; j++) {
            G[i][j] = 999;
        }
    }

    int numEdges;
    printf("Enter number of edges: ");
    scanf("%d", &numEdges);

    for (int i = 0; i < numEdges; i++) {
        printf("Enter edge (source dest and wt): ");
        scanf("%d %d %d", &u, &x, &wt);
        G[u][x] = wt;
    }

    int startVertex;
    printf("Enter start vertex: ");
    scanf("%d", &startVertex);

    dijkstras(v, G, startVertex);

    return 0;
}



//dijiktras list 

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int vertex;
    int wt;
    struct Node* next;
};

struct graph {
    int V;
    struct Node** Array;
};

struct Node* newNode(int data, int w) {
    struct Node* newN = (struct Node*)malloc(sizeof(struct Node));
    newN->vertex = data;
    newN->wt = w;
    newN->next = NULL;
    return newN;
}

void Adjlist(struct graph* g, int ver) {
    int e, u, v, w;
    struct Node* p;
    struct Node* new;

    printf("Enter number of edges: ");
    scanf("%d", &e);

    for (int i = 0; i < e; i++) {
        printf("Enter edge and weight: ");
        scanf("%d %d %d", &u, &v, &w);

        // Add edge u -> v with weight w
        new = newNode(v, w);
        new->next = g->Array[u];
        g->Array[u] = new;

        // Add edge v -> u with weight w (assuming undirected graph)
        new = newNode(u, w);
        new->next = g->Array[v];
        g->Array[v] = new;
    }
}

int minvertex(int dist[], int visited[], int v) {
    int minimum = 9999;
    int idx;

    for (int i = 0; i < v; i++) {
        if (visited[i] == 0 && dist[i] < minimum) {
            minimum = dist[i];
            idx = i;
        }
    }
    return idx;
}

void display(int dist[], int start, int v) {
    for (int i = 0; i < v; i++) {
        printf("Distance from %d to %d is %d \n", start, i, dist[i]);
    }
}

void dijkstras(struct graph* g, int v) {
    int visited[v];
    int dist[v];
    int st;

    for (int i = 0; i < v; i++) {
        dist[i] = 9999;
        visited[i] = 0;
    }

    printf("Enter start vertex: ");
    scanf("%d", &st);

    dist[st] = 0;

    for (int i = 0; i < v - 1; i++) {
        int f = minvertex(dist, visited, v);
        visited[f] = 1;

        struct Node* p = g->Array[f];
        while (p != NULL) {
            if (visited[p->vertex] == 0 && dist[p->vertex] > p->wt + dist[f]) {
                dist[p->vertex] = dist[f] + p->wt;
            }
            p = p->next;
        }
    }

    display(dist, st, v);
}

int main() {
    int v;
    printf("Enter number of vertices: ");
    scanf("%d", &v);

    struct graph* g = (struct graph*)malloc(sizeof(struct graph));
    g->V = v;
    g->Array = (struct Node**)malloc(v * sizeof(struct Node*));

    for (int i = 0; i < v; i++) {
        g->Array[i] = NULL;
    }

    Adjlist(g, v);
    dijkstras(g, v);

    return 0;
}







//// two queue: 
#include <stdio.h>
#include <stdlib.h>

struct TwoQueues {
    int *arr;
    int size;
    int front1, rear1, front2, rear2;
};

// Function to create two queues in an array of given size
struct TwoQueues* createTwoQueues(int n) {
    struct TwoQueues* tq = (struct TwoQueues*)malloc(sizeof(struct TwoQueues));
    tq->size = n;
    tq->arr = (int*)malloc(n * sizeof(int));
    tq->front1 = -1;
    tq->rear1 = -1;
    tq->front2 = n;
    tq->rear2 = n;
    return tq;
}

// Method to enqueue an element to the first queue
void enqueue1(struct TwoQueues* tq, int x) {
    if (tq->rear1 < tq->front2 - 1) {
        if (tq->front1 == -1) {
            tq->front1 = 0;
        }
        tq->rear1++;
        tq->arr[tq->rear1] = x;
    } else {
        printf("Queue Overflow by element: %d\n", x);
    }
}

// Method to enqueue an element to the second queue
void enqueue2(struct TwoQueues* tq, int x) {
    if (tq->rear2 > tq->rear1 + 1) {
        if (tq->front2 == tq->size) {
            tq->front2 = tq->size - 1;
        }
        tq->rear2--;
        tq->arr[tq->rear2] = x;
    } else {
        printf("Queue Overflow by element: %d\n", x);
    }
}

// Method to dequeue an element from the first queue
int dequeue1(struct TwoQueues* tq) {
    if (tq->front1 != -1) {
        int x = tq->arr[tq->front1];
        if (tq->front1 == tq->rear1) {
            tq->front1 = -1;
            tq->rear1 = -1;
        } else {
            tq->front1++;
        }
        return x;
    } else {
        printf("Queue Underflow\n");
        exit(1);
    }
}

// Method to dequeue an element from the second queue
int dequeue2(struct TwoQueues* tq) {
    if (tq->front2 != tq->size) {
        int x = tq->arr[tq->front2];
        if (tq->front2 == tq->rear2) {
            tq->front2 = tq->size;
            tq->rear2 = tq->size;
        } else {
            tq->front2--;
        }
        return x;
    } else {
        printf("Queue Underflow\n");
        exit(1);
    }
}

int main() {
    struct TwoQueues* tq = createTwoQueues(10);
    enqueue1(tq, 5);
    enqueue2(tq, 10);
    enqueue2(tq, 15);
    enqueue1(tq, 11);
    enqueue2(tq, 7);

    printf("Dequeued element from queue1 is: %d\n", dequeue1(tq));
    enqueue2(tq, 40);
    printf("Dequeued element from queue2 is: %d\n", dequeue2(tq));

    // Clean up
    free(tq->arr);
    free(tq);

    return 0;
}






/// mul poly 
struct poly* mulPoly(struct poly* p1,struct poly* p2){
    struct poly * ans2 = NULL;
    while(p1!= NULL){
struct poly * temp = p2;
      while(temp != NULL){
        struct poly* term = (struct poly*)malloc(sizeof(struct poly));
        term -> coeff = p1->coeff * p2->coeff;
        term -> exp = p1->exp + p2->exp;
        term ->next = NULL;
        addPoly(ans2,term);
        temp = temp->next;
      }
      p1=p1->next;
    }
return ans2;
}





// inorderusingts:
// void PostOrder(struct Node* root){
//     struct stack *s1 = NULL;
//     struct stack *s2 = NULL;
//     Push(root,&s1); 

//     while(!stackempty(s1)){
//         // struct Node* temp = Pop(&s1); 
//         struct Node* temp = (s1->T);
//         Pop(&s1);
//         Push(temp,&s2);

//         if(temp->left != NULL){
//             Push(temp->left, &s1);
//         }
//         if(temp->right != NULL){
//             Push(temp->right, &s1);
//         }
//     }

//     while(!stackempty(s2)){
//         struct Node* temp = Pop(&s2); 
//         printf("%d ",temp->data);
//     }
// }


